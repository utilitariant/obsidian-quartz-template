/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/main.ts
__export(exports, {
  default: () => HeadingIndent
});
var import_obsidian2 = __toModule(require("obsidian"));

// src/editingMode.ts
var import_language = __toModule(require("@codemirror/language"));
var import_state = __toModule(require("@codemirror/state"));
var import_view = __toModule(require("@codemirror/view"));
var indentStateField = import_state.StateField.define({
  create(state) {
    return getDecorationSet(state);
  },
  update(currentValue, tr) {
    for (const e of tr.effects) {
      if (e.is(updateNeededNotificationEffect)) {
        return getDecorationSet(tr.state);
      }
    }
    if (syntaxTreeChanged(tr)) {
      return getDecorationSet(tr.state);
    }
    return currentValue;
  },
  provide(field) {
    return import_view.EditorView.decorations.from(field, (value) => value.decorations);
  }
});
function syntaxTreeChanged(tr) {
  const oldTree = (0, import_language.syntaxTree)(tr.startState);
  const newTree = (0, import_language.syntaxTree)(tr.state);
  return oldTree !== newTree;
}
function getDecorationSet(state) {
  var _a;
  const settings = window.app.plugins.plugins["heading-level-indent"].settings;
  const headings = [];
  let highestLevelInDocument = 6;
  (0, import_language.syntaxTree)(state).iterate({
    enter(node) {
      if (node.type.name.startsWith("HyperMD-header_HyperMD-header-")) {
        const lineAt = state.doc.lineAt(node.from);
        const text = state.doc.sliceString(node.from, node.to);
        const level = Number(node.type.name.slice(-1));
        const posAt = node.from;
        headings.push({
          text,
          level,
          headingLineNumber: lineAt.number,
          headingPos: posAt
        });
        highestLevelInDocument = Math.min(highestLevelInDocument, level);
      }
    }
  });
  if (settings.treatHighestPresentHeadingAsH1) {
    for (const heading of headings) {
      heading.level -= highestLevelInDocument - 1;
    }
  }
  const builder = new import_state.RangeSetBuilder();
  const el = document.querySelector(".workspace-leaf.mod-active .cm-content");
  if (el === null)
    return { decorations: import_view.Decoration.none, intervals: [] };
  const containerWidth = parseInt(getComputedStyle(el).width);
  const intervals = [];
  for (const [index, heading] of headings.entries()) {
    const { level, headingLineNumber, headingPos } = heading;
    const headingLine = state.doc.line(headingLineNumber);
    const firstDataLineNumber = headingLineNumber + 1;
    const lastDataLineNumber = ((_a = headings[index + 1]) == null ? void 0 : _a.headingLineNumber) - 1 || state.doc.lines;
    const pxForDataLine = settings[`h${level}`] || 0;
    const pxForHeadingLine = settings[`h${level - 1}` || 0];
    intervals.push([headingPos, pxForDataLine]);
    const dataStyles = `left:${pxForDataLine}px;width:${containerWidth - pxForDataLine}px;`;
    const headingStyles = `left:${pxForHeadingLine}px;width:${containerWidth - pxForHeadingLine}px;`;
    builder.add(headingLine.from, headingLine.from, import_view.Decoration.line({
      attributes: { style: headingStyles }
    }));
    for (let j = firstDataLineNumber; j < lastDataLineNumber + 1; j++) {
      const dataLine = state.doc.line(j);
      builder.add(dataLine.from, dataLine.from, import_view.Decoration.line({
        attributes: { style: dataStyles }
      }));
    }
  }
  return { decorations: builder.finish(), intervals };
}
var indentEmbedsPlugin = import_view.ViewPlugin.fromClass(class {
  constructor(view) {
    this.view = view;
    this.scheduleIndentEmbedsAfterRender();
  }
  update(update) {
    for (const tr of update.transactions) {
      for (const e of tr.effects) {
        if (e.is(updateNeededNotificationEffect)) {
          this.scheduleIndentEmbedsAfterRender();
        }
      }
    }
    if (update.docChanged || update.viewportChanged) {
      this.scheduleIndentEmbedsAfterRender();
    }
  }
  scheduleIndentEmbedsAfterRender() {
    this.view.requestMeasure({
      read: () => {
      },
      write: (measure, view) => {
        const { intervals } = view.state.field(indentStateField);
        const dom = this.view.dom;
        const el = document.querySelector(".workspace-leaf.mod-active .cm-content");
        if (el === null)
          return;
        const containerWidth = parseInt(getComputedStyle(el).width);
        const embeds = Array.from(dom.querySelectorAll("div.cm-content > div.cm-embed-block"));
        const mathBlocks = Array.from(dom.querySelectorAll("div.cm-content > div.math-block"));
        let prevIntervalIndex = 0;
        for (const embed of [...embeds, ...mathBlocks]) {
          const [intervalIndex, offset] = findIntervalOffset(intervals, view.posAtDOM(embed), prevIntervalIndex);
          prevIntervalIndex = intervalIndex;
          embed.style.left = `${offset}px`;
          embed.style.width = `${containerWidth - offset}px`;
        }
        const internalEmbeds = Array.from(dom.querySelectorAll("div.cm-content > div.internal-embed"));
        prevIntervalIndex = 0;
        for (const embed of internalEmbeds) {
          const [intervalIndex, offset] = findIntervalOffset(intervals, view.posAtDOM(embed), prevIntervalIndex);
          prevIntervalIndex = intervalIndex;
          embed.style.position = "relative";
          embed.style.left = `${offset}px`;
          embed.style.width = `${containerWidth - offset}px`;
        }
        const imgs = Array.from(dom.querySelectorAll("div.cm-content > img"));
        prevIntervalIndex = 0;
        for (const img of imgs) {
          const [intervalIndex, offset] = findIntervalOffset(intervals, view.posAtDOM(img), prevIntervalIndex);
          prevIntervalIndex = intervalIndex;
          img.style.position = "relative";
          img.style.left = `${offset}px`;
          img.style.maxWidth = `${containerWidth - offset}px`;
        }
      }
    });
  }
});
function findIntervalOffset(intervals, pos, start) {
  if (!intervals.length || pos < intervals[0][0]) {
    return [0, 0];
  }
  let low = start;
  let high = intervals.length - 1;
  let result = [0, 0];
  while (low <= high) {
    const mid = low + high >> 1;
    const [midPos, midOffset] = intervals[mid];
    if (midPos < pos) {
      result = [mid, midOffset];
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }
  return result;
}
var updateNeededNotificationEffect = import_state.StateEffect.define();
var resizeNotificationPlugin = import_view.ViewPlugin.define((view) => {
  let resizeTimeout;
  const observer = new ResizeObserver((entries) => {
    clearTimeout(resizeTimeout);
    resizeTimeout = window.setTimeout(() => {
      view.dispatch({
        effects: updateNeededNotificationEffect.of()
      });
    }, 100);
  });
  observer.observe(view.dom);
  return {
    destroy() {
      observer.disconnect();
    }
  };
});

// src/readingMode.ts
var ShitIndenting = class {
  constructor(plugin) {
    this.plugin = plugin;
    this.containerSelector = ".workspace-leaf.mod-active .markdown-reading-view .markdown-preview-section";
    this.arrClassesHeadings = {
      1: "heading_h1",
      2: "heading_h2",
      3: "heading_h3",
      4: "heading_h4",
      5: "heading_h5",
      6: "heading_h6"
    };
    this.arrClassesData = {
      0: "data_no-heading",
      1: "data_h1",
      2: "data_h2",
      3: "data_h3",
      4: "data_h4",
      5: "data_h5",
      6: "data_h6"
    };
  }
  setObserverToActiveLeaf(plugin) {
    if (this.previewObserver !== void 0) {
      this.previewObserver.disconnect();
    }
    const targetNode = activeDocument.querySelector(this.containerSelector);
    if (targetNode == null) {
      return;
    }
    const config = { childList: true };
    const callback = (mutationList, observer) => {
      for (const mutation of mutationList) {
        if (mutation.type === "childList") {
          this.applyIndent(plugin, 0, true, "mutation");
        }
      }
    };
    this.previewObserver = new MutationObserver(callback);
    this.previewObserver.observe(targetNode, config);
  }
  applyIndent(plugin, timeout, flag, text = "") {
    timeout = timeout || 0;
    if (timeout == 0 && flag === false) {
      this.applyIndentation(plugin);
      return;
    }
    if (flag) {
      if (this.flagExecute == void 0 || this.flagExecute == 1) {
        this.flagExecute = 2;
        setTimeout(() => {
          this.applyIndentation(plugin);
        }, timeout);
        setTimeout(() => {
          this.flagExecute = 1;
        }, timeout + 50);
      }
    } else {
      setTimeout(() => {
        this.applyIndentation(plugin);
      }, timeout);
    }
  }
  applyIndentation(plugin) {
    const settings = plugin.settings;
    const divsNodeList = activeDocument.querySelectorAll(this.containerSelector + " > div");
    if (!divsNodeList) {
      return;
    }
    const arrDivs = Array.from(divsNodeList);
    const excludedClassNames = ["mod-header", "mod-footer", "markdown-preview-pusher"];
    this.cleanSectionModifications(arrDivs);
    const arrMargins = {
      0: 0,
      1: parseInt(settings.h1) || 0,
      2: parseInt(settings.h2) || 0,
      3: parseInt(settings.h3) || 0,
      4: parseInt(settings.h4) || 0,
      5: parseInt(settings.h5) || 0,
      6: parseInt(settings.h6) || 0
    };
    let hNumber = 0;
    suck:
      for (const div of arrDivs) {
        if (excludedClassNames.some((className) => div.classList.contains(className))) {
          continue suck;
        }
        const headingNodeList = div.querySelectorAll("h1, h2, h3, h4, h5, h6"), currentDivIsHeading = headingNodeList.length > 0;
        if (currentDivIsHeading) {
          const hTag = headingNodeList[0].tagName.toLowerCase();
          hNumber = parseInt(hTag.replace(/^\D+/g, ""));
          div.style.paddingLeft = arrMargins[hNumber - 1] + "px";
          div.classList.add(this.arrClassesHeadings[hNumber]);
        } else {
          div.style.paddingLeft = arrMargins[hNumber] + "px";
          div.classList.add(this.arrClassesData[hNumber]);
        }
      }
  }
  cleanSectionModifications(arrDivs) {
    for (const div of arrDivs) {
      div.style.paddingLeft = null;
      div.classList.forEach((item) => {
        if (item.startsWith("data_") || item.startsWith("heading_")) {
          div.classList.remove(item);
        }
      });
    }
  }
};

// src/settings.ts
var import_obsidian = __toModule(require("obsidian"));
var DEFAULT_SETTINGS = {
  h1: "30",
  h2: "50",
  h3: "70",
  h4: "90",
  h5: "110",
  h6: "130",
  enableReading: true,
  enableEditing: true,
  treatHighestPresentHeadingAsH1: false
};
var IndentSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    this.displayGeneralSetting(containerEl);
    containerEl.createEl("h3", {
      text: "Set indentation for the content of each heading in pixels"
    });
    containerEl.createEl("div", {
      text: `Indentation applied for the heading lines itself will be the same as the
						content of inmediately previous heading. For example, if the indentation 
						for the content of H3 is set to 70 pixels, H2 heading line itself
						will be indented the same`,
      attr: { style: "margin-bottom: 10px; color: gray;" }
    });
    new import_obsidian.Setting(containerEl).setName("Content under H1").addText((number) => number.setPlaceholder("").setValue(this.plugin.settings.h1).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.h1 = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Content under H2").addText((text) => text.setPlaceholder("").setValue(this.plugin.settings.h2).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.h2 = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Content under H3").addText((text) => text.setPlaceholder("").setValue(this.plugin.settings.h3).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.h3 = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Content under H4").addText((text) => text.setPlaceholder("").setValue(this.plugin.settings.h4).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.h4 = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Content under H5").addText((text) => text.setPlaceholder("").setValue(this.plugin.settings.h5).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.h5 = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Content under H6").addText((text) => text.setPlaceholder("").setValue(this.plugin.settings.h6).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.h6 = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Treat the highest present heading in the document as H1 (editing mode only)").addToggle((toggle) => toggle.setValue(this.plugin.settings.treatHighestPresentHeadingAsH1).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.treatHighestPresentHeadingAsH1 = value;
      yield this.plugin.saveSettings();
    })));
  }
  displayGeneralSetting(containerEl) {
    new import_obsidian.Setting(containerEl).setName("Enabled in editing mode (reload required)").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableEditing).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.enableEditing = value;
      yield this.plugin.saveSettings();
    })));
    new import_obsidian.Setting(containerEl).setName("Enabled in reading view").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableReading).onChange((value) => __async(this, null, function* () {
      this.plugin.settings.enableReading = value;
      yield this.plugin.saveSettings();
    })));
  }
};

// src/main.ts
var HeadingIndent = class extends import_obsidian2.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.addSettingTab(new IndentSettingTab(this.app, this));
      if (this.settings.enableReading)
        this.shitRunner();
      if (this.settings.enableEditing) {
        this.registerEditorExtension(indentStateField);
        this.registerEditorExtension(indentEmbedsPlugin);
        this.registerEditorExtension(resizeNotificationPlugin);
      }
    });
  }
  onunload() {
    this.shitCleaner();
  }
  loadSettings() {
    return __async(this, null, function* () {
      this.settings = Object.assign({}, DEFAULT_SETTINGS, yield this.loadData());
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
      yield this.saveData(this.settings);
      this.settings.enableReading ? this.shitRunner() : this.shitCleaner();
      this.app.workspace.iterateAllLeaves((leaf) => {
        var _a;
        const view = (_a = leaf.view.editor) == null ? void 0 : _a.cm;
        if (view) {
          view.dispatch({
            effects: updateNeededNotificationEffect.of()
          });
        }
      });
    });
  }
  shitRunner() {
    this.shitIndenting = new ShitIndenting(this);
    this.app.workspace.onLayoutReady(() => {
    });
    this.layoutChange = this.app.workspace.on("layout-change", () => {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
      if (!activeView || activeView.getViewType() !== "markdown") {
        return;
      }
      const view = activeView;
      const mode = view.getMode();
      if (mode == "preview") {
        this.shitIndenting.applyIndent(this, 0, false, "layout-change");
        this.shitIndenting.setObserverToActiveLeaf(this);
      }
    });
    this.activeLeafChangeListener = this.app.workspace.on("active-leaf-change", (leaf) => {
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian2.MarkdownView);
      if (!activeView || activeView.getViewType() !== "markdown") {
        return;
      }
      const view = activeView;
      const mode = view.getMode();
      if (mode == "preview") {
        this.shitIndenting.applyIndent(this, 0, false, "active-leaf-change-1");
        this.shitIndenting.applyIndent(this, 200, false, "active-leaf-change-2");
        this.shitIndenting.setObserverToActiveLeaf(this);
      }
    });
  }
  shitCleaner() {
    this.shitIndenting && this.shitIndenting.previewObserver && this.shitIndenting.previewObserver.disconnect();
    this.app.workspace.offref(this.activeLeafChangeListener);
    this.app.workspace.offref(this.layoutChange);
  }
};

/* nosourcemap */